__all__ = ["create", "get", "get_all", "update", "delete", "check", "exists"]

from typing import List, Optional, Mapping, Any
from databases import Database

from lain_backend.models import Vulnerability as model
from lain_backend.schemas import (
    VulnerabilityCreate,
    VulnerabilityIn,
    VulnerabilityUpdate,
    VulnerabilityUpdateIn,
)
from lain_backend.cruds import (
    peoples_vulnerabilities,
    networks_vulnerabilities,
    hosts_vulnerabilities,
    services_vulnerabilities,
)


async def create(db: Database, vulnerability: VulnerabilityIn) -> Optional[Mapping[Any, Any]]:
    vulnerability_create = VulnerabilityCreate(**vulnerability.dict())

    vulnerability_id = await db.execute(model.insert().values(**vulnerability_create.dict()))

    if vulnerability.people_ids is not None:
        for pid in vulnerability.people_ids:
            await peoples_vulnerabilities.create(
                db=db, people_id=pid, vulnerability_id=vulnerability_id
            )

    if vulnerability.network_ids is not None:
        for nid in vulnerability.network_ids:
            await networks_vulnerabilities.create(
                db=db, network_id=nid, vulnerability_id=vulnerability_id
            )

    if vulnerability.host_ids is not None:
        for hid in vulnerability.host_ids:
            await hosts_vulnerabilities.create(
                db=db, host_id=hid, vulnerability_id=vulnerability_id
            )

    if vulnerability.service_ids is not None:
        for sid in vulnerability.service_ids:
            await services_vulnerabilities.create(
                db=db, service_id=sid, vulnerability_id=vulnerability_id
            )

    return await get(db=db, vulnerability_id=vulnerability_id)


async def get(db: Database, vulnerability_id: int) -> Optional[Mapping[Any, Any]]:
    return await db.fetch_one(model.select().where(model.c.id == vulnerability_id))


async def get_all(db: Database, skip: int = 0, limit: int = 100) -> List[Mapping[Any, Any]]:
    return await db.fetch_all(model.select().offset(skip).limit(limit))


async def delete(db: Database, vulnerability_id: int) -> None:
    await db.execute(model.delete().where(model.c.id == vulnerability_id))

    return


async def update(
    db: Database, vulnerability: VulnerabilityUpdateIn, vulnerability_id: int
) -> Optional[Mapping[Any, Any]]:
    vulnerability_update = VulnerabilityUpdate(**vulnerability.dict())

    await db.execute(
        model.update()
        .values({**vulnerability_update.dict(exclude_none=True)})
        .where(model.c.id == vulnerability_id)
    )

    if vulnerability.people_ids is not None:
        await peoples_vulnerabilities.update(
            db=db, people_ids=vulnerability.people_ids, vulnerability_id=vulnerability_id
        )

    if vulnerability.network_ids is not None:
        await networks_vulnerabilities.update(
            db=db, network_ids=vulnerability.network_ids, vulnerability_id=vulnerability_id
        )

    if vulnerability.host_ids is not None:
        await hosts_vulnerabilities.update(
            db=db, host_ids=vulnerability.host_ids, vulnerability_id=vulnerability_id
        )

    if vulnerability.service_ids is not None:
        await services_vulnerabilities.update(
            db=db, service_ids=vulnerability.service_ids, vulnerability_id=vulnerability_id
        )

    return await get(db=db, vulnerability_id=vulnerability_id)


async def check(db: Database, vulnerability_id: int) -> bool:
    return (await get(db=db, vulnerability_id=vulnerability_id)) is not None
